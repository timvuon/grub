From 4b19cd9780edbca2148b88ceea1f72445ff64645 Mon Sep 17 00:00:00 2001
From: Colin Watson <cjwatson@ubuntu.com>
Date: Mon, 13 Jan 2014 12:13:28 +0000
Subject: Add configure option to bypass boot menu if possible

If other operating systems are installed, then automatically unhide the
menu.  Otherwise, if GRUB_HIDDEN_TIMEOUT is 0, then use keystatus if
available to check whether Shift is pressed.  If it is, show the menu,
otherwise boot immediately.  If keystatus is not available, then fall
back to a short delay interruptible with Escape.

This may or may not remain Ubuntu-specific, although it's not obviously
wanted upstream.  It implements a requirement of
https://wiki.ubuntu.com/DesktopExperienceTeam/KarmicBootExperienceDesignSpec#Bootloader.

If the previous boot failed (defined as failing to get to the end of one
of the normal runlevels), then show the boot menu regardless.

Author: Richard Laager <rlaager@wiktel.com>
Forwarded: no
Last-Update: 2014-01-17

Patch-Name: quick_boot.patch
---
 configure.ac                | 11 +++++++++
 docs/grub.texi              |  9 +++++++
 grub-core/normal/menu.c     | 24 +++++++++++++++++++
 util/grub-mkconfig.in       |  3 ++-
 util/grub.d/00_header.in    | 58 +++++++++++++++++++++++++++++++++++----------
 util/grub.d/10_linux.in     |  4 ++++
 util/grub.d/30_os-prober.in | 21 ++++++++++++++++
 7 files changed, 117 insertions(+), 13 deletions(-)

Index: grub/configure.ac
===================================================================
--- grub.orig/configure.ac	2015-03-23 16:53:55.970256793 +0100
+++ grub/configure.ac	2015-03-23 16:54:04.114154407 +0100
@@ -1678,6 +1678,17 @@
 fi
 AC_SUBST([QUIET_BOOT])
 
+AC_ARG_ENABLE([quick-boot],
+              [AS_HELP_STRING([--enable-quick-boot],
+                              [bypass boot menu if possible (default=no)])],
+              [], [enable_quick_boot=no])
+if test x"$enable_quick_boot" = xyes ; then
+  QUICK_BOOT=1
+else
+  QUICK_BOOT=0
+fi
+AC_SUBST([QUICK_BOOT])
+
 LIBS=""
 
 AC_SUBST([FONT_SOURCE])
Index: grub/docs/grub.texi
===================================================================
--- grub.orig/docs/grub.texi	2015-03-23 16:51:48.527858959 +0100
+++ grub/docs/grub.texi	2015-03-23 16:54:04.114154407 +0100
@@ -1490,6 +1490,15 @@
 Each module will be loaded as early as possible, at the start of
 @file{grub.cfg}.
 
+@item GRUB_RECORDFAIL_TIMEOUT
+If this option is set, it overrides the default recordfail setting. The
+default setting is -1, which causes GRUB to wait for user input. This option
+should be set on headless and appliance systems where access to a console is
+restricted or limited.
+
+This option is only effective when GRUB was configured with the
+@option{--enable-quick-boot} option.
+
 @end table
 
 The following options are still accepted for compatibility with existing
Index: grub/grub-core/normal/menu.c
===================================================================
--- grub.orig/grub-core/normal/menu.c	2015-03-23 16:53:55.974256743 +0100
+++ grub/grub-core/normal/menu.c	2015-03-23 16:54:04.114154407 +0100
@@ -604,6 +604,30 @@
       static struct grub_term_coordinate *pos;
       int entry = -1;
 
+      if (timeout == 0)
+	{
+	  /* If modifier key statuses can't be detected without a delay,
+	     then a hidden timeout of zero cannot be interrupted in any way,
+	     which is not very helpful.  Bump it to three seconds in this
+	     case to give the user a fighting chance.  */
+	  grub_term_input_t term;
+	  int nterms = 0;
+	  int mods_detectable = 1;
+
+	  FOR_ACTIVE_TERM_INPUTS(term)
+	  {
+	    if (!term->getkeystatus)
+	      {
+		mods_detectable = 0;
+		break;
+	      }
+	    else
+	      nterms++;
+	  }
+	  if (!mods_detectable || !nterms)
+	    timeout = 3;
+	}
+
       if (timeout_style == TIMEOUT_STYLE_COUNTDOWN && timeout)
 	{
 	  pos = grub_term_save_pos ();
Index: grub/util/grub-mkconfig.in
===================================================================
--- grub.orig/util/grub-mkconfig.in	2015-03-23 16:53:13.026796665 +0100
+++ grub/util/grub-mkconfig.in	2015-03-23 16:54:04.118154359 +0100
@@ -236,7 +236,8 @@
   GRUB_ENABLE_CRYPTODISK \
   GRUB_BADRAM \
   GRUB_OS_PROBER_SKIP_LIST \
-  GRUB_DISABLE_SUBMENU
+  GRUB_DISABLE_SUBMENU \
+  GRUB_RECORDFAIL_TIMEOUT
 
 if test "x${grub_cfg}" != "x"; then
   rm -f "${grub_cfg}.new"
Index: grub/util/grub.d/00_header.in
===================================================================
--- grub.orig/util/grub.d/00_header.in	2015-03-23 16:51:48.527858959 +0100
+++ grub/util/grub.d/00_header.in	2015-03-23 16:54:04.118154359 +0100
@@ -21,6 +21,8 @@
 exec_prefix="@exec_prefix@"
 datarootdir="@datarootdir@"
 grub_lang=`echo $LANG | cut -d . -f 1`
+grubdir="`echo "/@bootdirname@/@grubdirname@" | sed 's,//*,/,g'`"
+quick_boot="@QUICK_BOOT@"
 
 export TEXTDOMAIN=@PACKAGE@
 export TEXTDOMAINDIR="@localedir@"
@@ -44,6 +46,7 @@
 
 cat << EOF
 if [ -s \$prefix/grubenv ]; then
+  set have_grubenv=true
   load_env
 fi
 EOF
@@ -96,7 +99,31 @@
     save_env saved_entry
   fi
 }
+EOF
+
+if [ "$quick_boot" = 1 ]; then
+    cat <<EOF
+function recordfail {
+  set recordfail=1
+EOF
+    FS="$(grub-probe --target=fs "${grubdir}")"
+    case "$FS" in
+      btrfs | cpiofs | newc | odc | romfs | squash4 | tarfs | zfs)
+	cat <<EOF
+  # GRUB lacks write support for $FS, so recordfail support is disabled.
+EOF
+	;;
+      *)
+	cat <<EOF
+  if [ -n "\${have_grubenv}" ]; then if [ -z "\${boot_once}" ]; then save_env recordfail; fi; fi
+EOF
+    esac
+    cat <<EOF
+}
+EOF
+fi
 
+cat <<EOF
 function load_video {
 EOF
 if [ -n "${GRUB_VIDEO_BACKEND}" ]; then
@@ -282,10 +309,16 @@
 
 make_timeout ()
 {
+    cat << EOF
+if [ "\${recordfail}" = 1 ] ; then
+  set timeout=${GRUB_RECORDFAIL_TIMEOUT:--1}
+else
+EOF
     if [ "x${3}" != "x" ] ; then
 	timeout="${2}"
 	style="${3}"
-    elif [ "x${1}" != "x" ] && [ "x${1}" != "x0" ] ; then
+    elif [ "x${1}" != "x" ] && \
+	 ([ "$quick_boot" = 1 ] || [ "x${1}" != "x0" ]) ; then
 	# Handle the deprecated GRUB_HIDDEN_TIMEOUT scheme.
 	timeout="${1}"
 	if [ "x${2}" != "x0" ] ; then
@@ -304,26 +337,27 @@
 	style="menu"
     fi
     cat << EOF
-if [ x\$feature_timeout_style = xy ] ; then
-  set timeout_style=${style}
-  set timeout=${timeout}
+  if [ x\$feature_timeout_style = xy ] ; then
+    set timeout_style=${style}
+    set timeout=${timeout}
 EOF
     if [ "x${style}" = "xmenu" ] ; then
 	cat << EOF
-# Fallback normal timeout code in case the timeout_style feature is
-# unavailable.
-else
-  set timeout=${timeout}
+  # Fallback normal timeout code in case the timeout_style feature is
+  # unavailable.
+  else
+    set timeout=${timeout}
 EOF
     else
 	cat << EOF
-# Fallback hidden-timeout code in case the timeout_style feature is
-# unavailable.
-elif sleep${verbose} --interruptible ${timeout} ; then
-  set timeout=0
+  # Fallback hidden-timeout code in case the timeout_style feature is
+  # unavailable.
+  elif sleep${verbose} --interruptible ${timeout} ; then
+    set timeout=0
 EOF
     fi
     cat << EOF
+  fi
 fi
 EOF
 }
Index: grub/util/grub.d/10_linux.in
===================================================================
--- grub.orig/util/grub.d/10_linux.in	2015-03-23 16:53:55.974256743 +0100
+++ grub/util/grub.d/10_linux.in	2015-03-23 16:54:04.118154359 +0100
@@ -22,6 +22,7 @@
 datarootdir="@datarootdir@"
 ubuntu_recovery="@UBUNTU_RECOVERY@"
 quiet_boot="@QUIET_BOOT@"
+quick_boot="@QUICK_BOOT@"
 
 . "@datadir@/@PACKAGE@/grub-mkconfig_lib"
 
@@ -117,6 +118,9 @@
   else
       echo "menuentry '$(echo "$os" | grub_quote)' ${CLASS} \$menuentry_id_option 'gnulinux-simple-$boot_device_id' {" | sed "s/^/$submenu_indentation/"
   fi      
+  if [ "$quick_boot" = 1 ]; then
+      echo "	recordfail" | sed "s/^/$submenu_indentation/"
+  fi
   if [ x$type != xrecovery ] ; then
       save_default_entry | grub_add_tab
   fi
Index: grub/util/grub.d/30_os-prober.in
===================================================================
--- grub.orig/util/grub.d/30_os-prober.in	2015-03-23 16:53:55.954256993 +0100
+++ grub/util/grub.d/30_os-prober.in	2015-03-23 16:54:04.118154359 +0100
@@ -20,12 +20,26 @@
 prefix="@prefix@"
 exec_prefix="@exec_prefix@"
 datarootdir="@datarootdir@"
+quick_boot="@QUICK_BOOT@"
 
 export TEXTDOMAIN=@PACKAGE@
 export TEXTDOMAINDIR="@localedir@"
 
 . "@datadir@/@PACKAGE@/grub-mkconfig_lib"
 
+found_other_os=
+
+adjust_timeout () {
+  if [ "$quick_boot" = 1 ] && [ "x${found_other_os}" != "x" ]; then
+    cat << EOF
+set timeout_style=menu
+if [ "\${timeout}" = 0 ]; then
+  set timeout=10
+fi
+EOF
+  fi
+}
+
 if [ "x${GRUB_DISABLE_OS_PROBER}" = "xtrue" ]; then
   exit 0
 fi
@@ -42,6 +56,7 @@
 fi
 
 osx_entry() {
+    found_other_os=1
     if [ x$2 = x32 ]; then
         # TRANSLATORS: it refers to kernel architecture (32-bit)
 	bitstr="$(gettext "(32-bit)")"
@@ -159,6 +174,7 @@
 	  ;;
       esac
 
+      found_other_os=1
 	  onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
       cat << EOF
 menuentry '$(echo "${LONGNAME} $onstr" | grub_quote)' --class windows --class os \$menuentry_id_option 'osprober-chain-$(grub_get_device_id "${DEVICE}")' {
@@ -189,6 +205,7 @@
     ;;
     efi)
 
+	found_other_os=1
 	EFIPATH=${DEVICE#*@}
 	DEVICE=${DEVICE%@*}
 	onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
@@ -237,6 +254,7 @@
 	  [ "${prepare_boot_cache}" ] || continue
 	fi
 
+	found_other_os=1
 	onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
 	recovery_params="$(echo "${LPARAMS}" | grep 'single\|recovery')" || true
 	counter=1
@@ -305,6 +323,7 @@
       fi
     ;;
     hurd)
+      found_other_os=1
       onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
       cat << EOF
 menuentry '$(echo "${LONGNAME} $onstr" | grub_quote)' --class hurd --class gnu --class os \$menuentry_id_option 'osprober-gnuhurd-/boot/gnumach.gz-false-$(grub_get_device_id "${DEVICE}")' {
@@ -347,3 +366,5 @@
     ;;
   esac
 done
+
+adjust_timeout
